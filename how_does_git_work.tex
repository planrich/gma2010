\section{How does git work internally?}

To understand how git works we need to know some basic commands.

\subsection {Basic commands}

As any other VCS git stores its data in the repository directory.
There are two major ways to get a repository.
One would be by simply creating a new empty git repository in your directory of choice:
\begin{lstlisting}
$ git init
\end{lstlisting}
This command creates a new subdirectory .git/ where all your version control
data is stored. \cite{gitinternals2008} p 55 \\
The second is to clone an existing repository over an URL. Possible protocols
are FILE SSH HTTPS HTTP or GIT. Of course on the target location must host a
git repository:
\begin{lstlisting}
$ git clone 
    git://github.com/rails/rails.git
\end{lstlisting}
Git will clone the whole ruby on rails project from github and we're
ready to get to work. \cite{gitinternals2008} p 56 \\

After we have a new repository we can add some content:
\begin{lstlisting}
$ touch README
$ git status
$ git add README
$ git commit -m "Added README file"
\end{lstlisting}

This code produces an empty README file. The status command displays any change
of the repository. There we can see that the README file has been added and we
track this file simply by telling git to add the file to the index. Additionally
git now stages the file, but we are going to cover the staging feature later in the next
section. Then we commit the changes with a short and descriptive message. After
this git stores the changes into the repository and points the default master
branch to the new commit. \cite{gitinternals2008} p 55 \\

After there has been committed a huge amount of work in the local ruby on rails
repository we can share the work telling git:

\begin{lstlisting}
$ git push origin master 
\end{lstlisting}

This command will only succeed if you have the appropriate access rights to the
project. But if we had them, the master parameter tells git to take the default
branch and transmit the changes to the host. We could also specify any other
branch and transmit it to the destination host. \\ 

Also one should know that the origin parameter is our destination. You can
simply add many different socalled remotes:

\begin{lstlisting}
$ git remote add [name] [url]
\end{lstlisting}

This command links a short name to any url and you can share your
work over any network git is designed for. \cite{gitpro2009} chapter 2.9 \\

The last very important command is:
\begin{lstlisting}
$ git fetch origin
\end{lstlisting}

The fetch command is used to get work from other people of your project since
the last time you fetched. Very important is that this command does not
automatically merge the new updates into your local master branch. It just
downloads the updates and creates a new brach FETCH\_HEAD. Then you have to
manually merge the branch FETCH\_HEAD to the desired branch. 
If you dont need this very powerful feature you can simply execute:
\begin{lstlisting}
$ git pull origin
\end{lstlisting}
Git will automatically merge the changes into your master branch.
\cite{gitpro2009} chapter 2.9 \\

\subsection {What makes git to a DVCS?}

Linus Torvalds did a quite good job to summarize what distributed means:

\zitat{Beeing distributed very much means that you do not have one
central location that keeps track of your data, no single place more important
than any other place\ldots} \cite{linustorvaldsgoogletalk2007}

Nearly all commands that git offer you are local operations. There is no need to
have any network connection at all to work on your project and track changes
afterwards. Moreover the whole history of your project is contained in your
local repository. Also all contributors of one project have that history if
they pull from you. Hence no repository has more information about the project
than the other.
